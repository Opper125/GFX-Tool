<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FPS GFX Tool</title>
  <style>
    /* Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* Body with Myanmar Map and Waves */
    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      background: linear-gradient(180deg, #1a1a1a, #2a2a2a);
      position: relative;
      overflow-x: hidden;
      color: #fff; /* Default text color */
    }

    /* Dashboard Background with Myanmar Map and 4D Waves */
    body.dashboard-active {
      background: url('/placeholder.svg?height=1080&width=1920') no-repeat center center / cover;
      animation: mapZoom 20s ease-in-out infinite;
      position: relative;
    }

    body.dashboard-active::before {
      content: '';
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      background: url('/placeholder.svg?height=200&width=2000') repeat-x bottom;
      background-size: 2000px 200px;
      animation: waveAnimation 10s linear infinite;
      z-index: -1;
      filter: drop-shadow(0 0 20px rgba(0, 191, 255, 0.5));
    }

    @keyframes mapZoom {
      0% { background-size: 100%; }
      50% { background-size: 110%; }
      100% { background-size: 100%; }
    }

    @keyframes waveAnimation {
      0% { background-position-x: 0; }
      100% { background-position-x: 2000px; }
    }

    /* Container */
    .container {
      background: rgba(34, 34, 34, 0.9);
      padding: 24px;
      border-radius: 16px;
      width: 100%;
      max-width: 480px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.8s ease-out;
      backdrop-filter: blur(10px);
      z-index: 1;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Typography */
    h1, h2, h3 {
      font-weight: 600;
      margin-bottom: 24px;
      text-align: center;
      color: #ffd700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    h1 { font-size: 28px; }
    h2 { font-size: 24px; }
    h3 { font-size: 20px; }

    /* Form Elements */
    input, select, button, textarea {
      width: 100%;
      padding: 12px;
      margin: 12px 0;
      border: none;
      border-radius: 8px;
      background: rgba(51, 51, 51, 0.8);
      color: #fff;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      background: rgba(68, 68, 68, 0.9);
      box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.5);
      transform: scale(1.02);
    }

    /* Button Styles with Myanmar Flag Animation */
    button {
      position: relative;
      background: linear-gradient(45deg, #ffd700, #ff8c00);
      font-weight: 600;
      cursor: pointer;
      overflow: hidden;
      z-index: 1;
      color: #333;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: url('/placeholder.svg?height=200&width=200') center / contain no-repeat;
      opacity: 0;
      transform: translate(-50%, -50%);
      transition: all 0.5s ease;
      z-index: -1;
    }

    button:hover::before {
      width: 200px;
      height: 200px;
      opacity: 0.3;
    }

    button:active::before {
      width: 300px;
      height: 300px;
      opacity: 0.5;
      animation: flagBurst 0.5s ease-out;
    }

    @keyframes flagBurst {
      0% { width: 0; height: 0; opacity: 0; }
      50% { width: 400px; height: 400px; opacity: 0.7; }
      100% { width: 300px; height: 300px; opacity: 0.5; }
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(255, 215, 0, 0.6);
    }

    /* Pro Badge */
    .pro-badge {
      position: fixed;
      top: 16px;
      right: 16px;
      background: linear-gradient(45deg, #ffd700, #ff8c00);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      animation: glow 1.5s ease-in-out infinite alternate;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      color: #333;
      display: none; /* Hidden by default */
    }

    @keyframes glow {
      from { box-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
      to { box-shadow: 0 0 16px rgba(255, 215, 0, 0.9); }
    }

    /* Messages */
    .message {
      padding: 12px;
      margin: 12px 0;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      animation: slideIn 0.5s ease-out;
      color: #fff;
    }

    .error { background: #ff4444; }
    .success { background: #44ff44; }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-16px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* Game Grid */
    .game-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
      margin: 16px 0;
    }

    .game-card {
      background: rgba(51, 51, 51, 0.8);
      padding: 12px;
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .game-card:hover {
      transform: scale(1.05);
      background: rgba(68, 68, 68, 0.9);
      box-shadow: 0 4px 16px rgba(255, 215, 0, 0.5);
    }

    .game-card img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      border-radius: 8px;
      margin-bottom: 8px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .game-card p {
      font-size: 14px;
      margin: 0;
      color: #fff;
    }

    /* Checkbox */
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 12px 0;
      font-size: 14px;
      color: #fff;
    }

    /* Menu */
    .menu {
      display: flex;
      justify-content: space-around;
      background: rgba(51, 51, 51, 0.8);
      padding: 12px;
      border-radius: 8px;
      margin-top: 24px;
    }

    .menu button {
      flex: 1;
      margin: 0 4px;
    }

    /* News Card */
    .news-card {
      background: rgba(51, 51, 51, 0.8);
      padding: 16px;
      border-radius: 12px;
      margin: 16px 0;
      transition: all 0.3s ease;
    }

    .news-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 16px rgba(255, 215, 0, 0.5);
    }

    .news-card img {
      max-width: 100%;
      border-radius: 8px;
      margin: 8px 0;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .news-card .views {
      font-size: 12px;
      color: #ffd700;
      text-align: right;
    }

    .news-card .author-info {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .news-card .author-info .profile-pic {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 8px;
      object-fit: cover;
    }

    /* Comments */
    .comment {
      background: rgba(68, 68, 68, 0.9);
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
      font-size: 14px;
      color: #fff;
    }

    .comment.reply {
      margin-left: 24px;
      border-left: 3px solid #ffd700;
      padding-left: 10px;
    }

    .comment .comment-author-info {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .comment .comment-author-info .profile-pic {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin-right: 6px;
      object-fit: cover;
    }

    /* Responsive Design */
    @media (max-width: 480px) {
      .container {
        padding: 16px;
      }
      h1, h2 {
        font-size: 20px;
      }
      input, select, button, textarea {
        font-size: 14px;
      }
      .menu {
        flex-direction: column;
      }
      .menu button {
        margin: 4px 0;
      }
      body.dashboard-active::before {
        height: 150px;
        background-size: 1500px 150px;
      }
    }
  </style>
</head>
<body>
  <div class="pro-badge" id="pro-badge">Pro</div>
  <div class="container" id="main-container">
    <h1>FPS GFX Tool</h1>
    <div id="status"></div>
    <button onclick="showAbout()">About</button>
    <div id="about-section" style="display: none;">
      <h2>About Us</h2>
      <div id="about-content"></div>
      <button onclick="hideAbout()">Back</button>
    </div>
    <input type="text" id="key-input" placeholder="Enter Key" required>
    <button onclick="login()">Login</button>
    <div id="main-content" style="display: none;">
      <div id="key-status-display" style="text-align: center; margin-bottom: 15px; color: #ffd700; font-weight: bold;"></div>
      <div id="home-section">
        <div id="game-selection">
          <h2>Select Game</h2>
          <div class="game-grid">
            <div class="game-card" onclick="selectGame('korean')">
              <img src="/placeholder.svg?height=80&width=80" alt="PUBG Korean">
              <p>PUBG Korean</p>
            </div>
            <div class="game-card" onclick="selectGame('global')">
              <img src="/placeholder.svg?height=80&width=80" alt="PUBG Global">
              <p>PUBG Global</p>
            </div>
          </div>
        </div>
        <div id="config-form" style="display: none;">
          <h2>Configure Settings</h2>
          <select id="fps">
            <option value="60">60 FPS</option>
            <option value="90">90 FPS</option>
            <option value="120">120 FPS</option>
            <option value="144">144 FPS</option>
          </select>
          <select id="bit-type">
            <option value="32bit">32-bit</option>
            <option value="64bit">64-bit</option>
          </select>
          <label class="checkbox-label">
            <input type="checkbox" id="ipad-view"> Enable iPad View
          </label>
          <input type="number" id="dpi" placeholder="DPI (e.g., 320)" disabled>
          <input type="text" id="resolution" placeholder="Resolution (e.g., 1920x1080)" disabled>
          <button onclick="generateFile()">Generate File</button>
          <button onclick="showSection('home')">Back to Game Selection</button>
        </div>
        <div id="files-list"></div>
      </div>
      <div id="news-section" style="display: none;">
        <h2>News</h2>
        <button onclick="showCreateProfile()" id="create-profile-btn">Create Profile</button>
        <div id="create-profile" style="display: none;">
          <h3>Create Profile</h3>
          <input type="text" id="profile-username" placeholder="Username" required>
          <input type="text" id="profile-name" placeholder="Name" required>
          <label class="checkbox-label">Profile Picture: <input type="file" id="profile-picture" accept="image/*"></label>
          <button onclick="createProfile()">Save Profile</button>
          <button onclick="hideCreateProfile()">Cancel</button>
        </div>
        <button onclick="showPostNews()" id="post-news-btn" style="display: none;">Post News</button>
        <div id="post-news" style="display: none;">
          <h3>Post News</h3>
          <input type="text" id="news-title" placeholder="Title" required>
          <textarea id="news-content" placeholder="Content" rows="5" required></textarea>
          <input type="text" id="news-youtube" placeholder="YouTube Link (Optional)">
          <label class="checkbox-label">News Image: <input type="file" id="news-image" accept="image/*"></label>
          <button onclick="postNews()">Post</button>
          <button onclick="hidePostNews()">Cancel</button>
        </div>
        <div id="news-list"></div>
      </div>
      <div id="support-section" style="display: none;">
        <h2>Support Chat</h2>
        <div id="support-messages" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px; border-radius: 8px; margin-bottom: 10px;"></div>
        <textarea id="support-input" placeholder="Type your message" rows="3"></textarea>
        <button onclick="sendSupportMessage()">Send</button>
      </div>
      <div id="telegram-section" style="display: none;">
        <h2>Telegram Channel Posts</h2>
        <div id="telegram-posts">
          <p>Telegram posts will appear here. (Note: Direct integration with Telegram channel API requires a backend server. This is a placeholder.)</p>
        </div>
      </div>
      <div class="menu">
        <button onclick="showSection('home')">Home</button>
        <button onclick="showSection('news')">News</button>
        <button onclick="showSection('support')">Support</button>
        <button onclick="showSection('telegram')">Telegram</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.min.js"></script>
  <script>
    // Constants
    const SUPABASE_URL = 'https://rliwdosxsbauwxkayjoa.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJsaXdkb3N4c2JhdXd4a2F5am9hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQxMDA2NjIsImV4cCI6MjA2OTY3NjY2Mn0.uDvU9eX3Cy--D9l6daGaO2QMpn1YnxMJYVlbaeIgHu4';
    const TELEGRAM_BOT_TOKEN = '8493584268:AAEpDAPbwRDJYBf9VjlxSiELc4bTrrn_7xw';
    const TELEGRAM_GROUP_ID = '-1002863080440'; // Note: This is a group ID, not a channel ID. Fetching channel posts directly from client-side is not feasible without a backend.

    let supabase = null;
    let deviceId = '';
    let sessionId = '';
    let keyExpiration = null;
    let profileId = null;
    let viewTimers = {};
    let expirationInterval = null;

    // Initialize Supabase client
    function initializeSupabase() {
      try {
        if (typeof Supabase === 'undefined') {
          showMessage('Supabase library not loaded. Please check your internet connection or try again.', 'error');
          return;
        }
        supabase = Supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          fetch: (url, options) => fetch(url, { ...options, cache: 'no-store' })
        });
        console.log('Supabase client initialized.');
        setupRealtimeSubscriptions();
      } catch (error) {
        console.error('Failed to initialize Supabase client:', error);
        showMessage(`Error initializing database: ${error.message}. Please check your network or refresh the page.`, 'error');
      }
    }

    // Check Internet Connectivity
    async function checkInternet() {
      if (!navigator.onLine) {
        console.error('No internet connection detected');
        showMessage('No internet connection! Please check your network and try again.', 'error');
        return false;
      }
      try {
        const response = await fetch(SUPABASE_URL + '/rest/v1/', {
          method: 'HEAD',
          cache: 'no-store',
          signal: AbortSignal.timeout(5000) // 5 seconds timeout
        });
        if (!response.ok) {
          throw new Error('Supabase server unreachable');
        }
        console.log('Internet connectivity verified');
        return true;
      } catch (error) {
        console.error('Internet check failed:', error);
        showMessage(`Failed to connect to server: ${error.message}. Please check your network or use a VPN.`, 'error');
        return false;
      }
    }

    function showMessage(message, type) {
      const status = document.getElementById('status');
      status.innerHTML = `<div class="message ${type}">${message}</div>`;
      setTimeout(() => {
        status.innerHTML = '';
        // Remove the message element after animation
        const msgElement = status.querySelector('.message');
        if (msgElement) {
          msgElement.style.animation = 'slideOut 0.5s ease-out forwards';
          msgElement.addEventListener('animationend', () => msgElement.remove());
        }
      }, 7000);
      console.log(`Message displayed: ${message} (${type})`);
    }

    async function showAbout() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const { data, error } = await supabase.from('about').select('*').single();
        if (error && error.code !== 'PGRST116') throw new Error(`About fetch error: ${error.message}`); // PGRST116 means no rows found
        
        let content = '<p>No contact information available.</p>';
        if (data) {
          content = `
            <p>Telegram: <a href="${data.telegram || '#'}" target="_blank">${data.telegram || 'N/A'}</a></p>
            <p>Viber: <a href="${data.viber || '#'}" target="_blank">${data.viber || 'N/A'}</a></p>
            <p>Phone: ${data.phone || 'N/A'}</p>
          `;
        }
        document.getElementById('about-content').innerHTML = content;
        document.getElementById('about-section').style.display = 'block';
        document.getElementById('key-input').style.display = 'none';
        document.querySelector('button[onclick="login()"]').style.display = 'none';
        document.querySelector('button[onclick="showAbout()"]').style.display = 'none';
        console.log('About section loaded successfully');
      } catch (error) {
        console.error('Error loading about section:', error);
        showMessage(`Error loading about: ${error.message}`, 'error');
      }
    }

    function hideAbout() {
      document.getElementById('about-section').style.display = 'none';
      document.getElementById('key-input').style.display = 'block';
      document.querySelector('button[onclick="login()"]').style.display = 'block';
      document.querySelector('button[onclick="showAbout()"]').style.display = 'block';
    }

    async function login() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const key = document.getElementById('key-input').value.trim();
        if (!key) {
          showMessage('Please enter a key!', 'error');
          return;
        }

        const { data: keyData, error: keyError } = await supabase
          .from('keys')
          .select('*')
          .eq('key_text', key)
          .eq('is_active', true)
          .single();
        if (keyError || !keyData) {
          throw new Error('Invalid or inactive key.');
        }
        if (new Date(keyData.expires_at) < new Date()) {
          throw new Error('Key expired.');
        }

        const deviceInfo = await detectDevice();
        deviceId = deviceInfo.id;

        // Check existing active sessions for this key and device
        const { data: existingSession, error: existingSessionError } = await supabase
          .from('sessions')
          .select('*')
          .eq('key_id', keyData.id)
          .eq('device_id', deviceId)
          .eq('is_active', true)
          .single();

        if (existingSession) {
          sessionId = existingSession.id;
          showMessage('Already logged in with this key on this device!', 'success');
        } else {
          // Check device limit for the key
          const { count: activeDeviceCount, error: countError } = await supabase
            .from('sessions')
            .select('device_id', { count: 'exact' })
            .eq('key_id', keyData.id)
            .eq('is_active', true);

          if (countError) throw new Error(`Failed to check device count: ${countError.message}`);

          if (activeDeviceCount >= keyData.max_devices) {
            throw new Error('This key has reached its maximum device limit.');
          }

          // Create new session
          const { data: newSessionData, error: insertError } = await supabase.from('sessions').insert({
            key_id: keyData.id,
            device_id: deviceId,
            is_active: true,
          }).select().single();
          if (insertError) throw new Error(`Failed to create session: ${insertError.message}`);
          sessionId = newSessionData.id;
          showMessage('Login successful!', 'success');
        }

        keyExpiration = new Date(keyData.expires_at);
        document.getElementById('key-input').style.display = 'none';
        document.querySelector('button[onclick="login()"]').style.display = 'none';
        document.querySelector('button[onclick="showAbout()"]').style.display = 'none';
        document.getElementById('main-content').style.display = 'block';
        document.body.classList.add('dashboard-active');
        document.getElementById('pro-badge').style.display = 'block'; // Show Pro badge
        startExpirationTimer(keyData.expires_at);
        loadUserFiles();
        checkProfile();
        console.log('Login successful, session ID:', sessionId);
      } catch (error) {
        console.error('Login error:', error);
        showMessage(`Login failed: ${error.message}`, 'error');
      }
    }

    async function detectDevice() {
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        throw new Error('Supabase client not initialized');
      }
      try {
        const ua = navigator.userAgent;
        let architecture = 'Unknown';
        if (ua.includes('arm64') || ua.includes('x86_64')) {
          architecture = '64bit';
        } else if (ua.includes('armv7l') || ua.includes('x86')) {
          architecture = '32bit';
        }

        const androidMatch = ua.match(/Android\s+([\d.]+)/);
        const modelMatch = ua.match(/\(([^;]+);/); // Basic attempt to get model from user agent

        const id = btoa(ua).slice(0, 255); // Simple hash of user agent for device ID

        const device = {
          id,
          user_agent: ua,
          architecture,
          android_version: androidMatch ? androidMatch[1] : 'Unknown',
          model: modelMatch ? modelMatch[1].trim() : 'Unknown',
        };

        const { error } = await supabase.from('devices').upsert(device, { onConflict: 'id' });
        if (error) throw new Error(`Device upsert error: ${error.message}`);
        console.log('Device detected and saved:', device);
        return device;
      } catch (error) {
        console.error('Detect device error:', error);
        showMessage(`Device detection failed: ${error.message}`, 'error');
        throw error;
      }
    }

    function startExpirationTimer(expiresAt) {
      if (expirationInterval) clearInterval(expirationInterval); // Clear any existing timer
      const expirationDate = new Date(expiresAt);
      
      expirationInterval = setInterval(() => {
        const now = new Date();
        const timeLeftMs = expirationDate.getTime() - now.getTime();

        if (timeLeftMs <= 0) {
          showMessage('Key expired! Logging out...', 'error');
          logout();
          clearInterval(expirationInterval);
          return;
        }

        const totalSeconds = Math.floor(timeLeftMs / 1000);
        const days = Math.floor(totalSeconds / (3600 * 24));
        const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const dayName = now.toLocaleString('en-US', { weekday: 'long' });
        const expirationDisplay = document.getElementById('key-status-display');
        expirationDisplay.innerHTML = `Key expires on ${dayName} in: ${days}d ${hours}h ${minutes}m ${seconds}s`;
      }, 1000);
      console.log('Expiration timer started');
    }

    async function logout() {
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        if (sessionId) {
          const { error } = await supabase.from('sessions').update({ is_active: false }).eq('id', sessionId);
          if (error) console.error('Failed to deactivate session on logout:', error);
        }
        
        sessionId = '';
        profileId = null;
        keyExpiration = null;
        if (expirationInterval) clearInterval(expirationInterval);
        document.getElementById('key-status-display').innerHTML = '';
        document.getElementById('main-content').style.display = 'none';
        document.getElementById('pro-badge').style.display = 'none';
        document.getElementById('key-input').style.display = 'block';
        document.querySelector('button[onclick="login()"]').style.display = 'block';
        document.querySelector('button[onclick="showAbout()"]').style.display = 'block';
        document.body.classList.remove('dashboard-active');
        showMessage('Logged out!', 'error');
        console.log('Logged out successfully');
      } catch (error) {
        console.error('Logout error:', error);
        showMessage(`Logout failed: ${error.message}`, 'error');
      }
    }

    function showSection(section) {
      try {
        document.getElementById('home-section').style.display = section === 'home' ? 'block' : 'none';
        document.getElementById('news-section').style.display = section === 'news' ? 'block' : 'none';
        document.getElementById('support-section').style.display = section === 'support' ? 'block' : 'none';
        document.getElementById('telegram-section').style.display = section === 'telegram' ? 'block' : 'none';
        
        // Hide sub-forms when switching main sections
        document.getElementById('create-profile').style.display = 'none';
        document.getElementById('post-news').style.display = 'none';

        if (section === 'news') loadNews();
        if (section === 'support') loadSupportMessages();
        if (section === 'telegram') loadTelegramPosts(); // This will show the placeholder message
        console.log(`Switched to ${section} section`);
      } catch (error) {
        console.error('Show section error:', error);
        showMessage(`Section switch failed: ${error.message}`, 'error');
      }
    }

    function selectGame(version) {
      try {
        document.getElementById('game-selection').style.display = 'none';
        document.getElementById('config-form').style.display = 'block';
        document.getElementById('config-form').dataset.game = version;
        console.log(`Game selected: ${version}`);
      } catch (error) {
        console.error('Select game error:', error);
        showMessage(`Game selection failed: ${error.message}`, 'error');
      }
    }

    document.getElementById('ipad-view').addEventListener('change', function() {
      const dpiInput = document.getElementById('dpi');
      const resolutionInput = document.getElementById('resolution');
      dpiInput.disabled = !this.checked;
      resolutionInput.disabled = !this.checked;
      if (!this.checked) {
        dpiInput.value = '';
        resolutionInput.value = '';
      }
    });

    async function generateFile() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!sessionId) {
        showMessage('Please login first to generate files.', 'error');
        return;
      }
      try {
        const fps = document.getElementById('fps').value;
        const bitType = document.getElementById('bit-type').value;
        const ipadView = document.getElementById('ipad-view').checked;
        const dpi = document.getElementById('dpi').value || null;
        const resolution = document.getElementById('resolution').value || null;
        const gameVersion = document.getElementById('config-form').dataset.game;

        // Simulate file content (actual GFX tool logic would be here)
        const fileContent = JSON.stringify({
          game: gameVersion,
          fps: parseInt(fps),
          bit: bitType,
          ipadView: ipadView,
          dpi: ipadView ? (dpi ? parseInt(dpi) : 'default') : 'N/A',
          resolution: ipadView ? (resolution || 'default') : 'N/A',
          generatedAt: new Date().toISOString(),
          keyExpires: keyExpiration.toISOString(),
          deviceId: deviceId
        }, null, 2);

        const fileName = `${gameVersion}_${fps}fps_${bitType}_${ipadView ? 'ipad' : 'normal'}_${Date.now()}.sav`;
        const filePath = `/FPS_OPPER/${fileName}`; // This is a conceptual path for database record

        const { error } = await supabase.from('generated_files').insert({
          session_id: sessionId,
          game_version: gameVersion,
          fps: parseInt(fps),
          bit_type: bitType,
          ipad_view: ipadView,
          dpi: dpi ? parseInt(dpi) : null,
          resolution,
          file_path: filePath, // Store the conceptual path
        });
        if (error) throw new Error(`File record insert error: ${error.message}`);

        // Create a Blob and trigger download
        const blob = new Blob([fileContent], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName; // User downloads this file
        document.body.appendChild(a); // Append to body to make it clickable in all browsers
        a.click();
        document.body.removeChild(a); // Clean up
        URL.revokeObjectURL(url); // Release the object URL

        showMessage('File generated and downloaded! Please manually move it to your PUBG game folder.', 'success');
        loadUserFiles();
        console.log('File generated and download initiated:', filePath);
      } catch (error) {
        console.error('Generate file error:', error);
        showMessage(`File generation failed: ${error.message}`, 'error');
      }
    }

    async function loadUserFiles() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!sessionId) {
        document.getElementById('files-list').innerHTML = '<h2>Your Files</h2><p>Login to see your generated files.</p>';
        return;
      }
      try {
        const { data, error } = await supabase
          .from('generated_files')
          .select('*')
          .eq('session_id', sessionId)
          .order('created_at', { ascending: false });
        if (error) throw new Error(`Files fetch error: ${error.message}`);

        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '<h2>Your Generated Files</h2>';
        if (data.length === 0) {
          filesList.innerHTML += '<p>No files generated yet.</p>';
          return;
        }
        data.forEach(file => {
          // The download link will point to a dummy URL, as the actual file is generated client-side
          // and needs to be re-generated for download if not stored on a server.
          // For simplicity, we'll just show the name and assume user knows how to re-generate/find.
          filesList.innerHTML += `
            <div style="background: rgba(51,51,51,0.8); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
              <p><strong>Game:</strong> ${file.game_version.toUpperCase()}</p>
              <p><strong>FPS:</strong> ${file.fps}</p>
              <p><strong>Bit Type:</strong> ${file.bit_type}</p>
              <p><strong>iPad View:</strong> ${file.ipad_view ? 'Yes' : 'No'}</p>
              <p><strong>Generated At:</strong> ${new Date(file.created_at).toLocaleString()}</p>
              <button onclick="reDownloadFile('${file.id}')">Download Again</button>
            </div>
          `;
        });
        console.log('User files loaded:', data.length);
      } catch (error) {
        console.error('Load files error:', error);
        showMessage(`Failed to load files: ${error.message}`, 'error');
      }
    }

    async function reDownloadFile(fileId) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const { data: fileData, error: fetchError } = await supabase
          .from('generated_files')
          .select('*')
          .eq('id', fileId)
          .single();
        if (fetchError || !fileData) throw new Error(`File not found: ${fetchError?.message}`);

        // Re-simulate file content for download
        const fileContent = JSON.stringify({
          game: fileData.game_version,
          fps: fileData.fps,
          bit: fileData.bit_type,
          ipadView: fileData.ipad_view,
          dpi: fileData.ipad_view ? (fileData.dpi || 'default') : 'N/A',
          resolution: fileData.ipad_view ? (fileData.resolution || 'default') : 'N/A',
          generatedAt: new Date(fileData.created_at).toISOString(),
          keyExpires: keyExpiration ? keyExpiration.toISOString() : 'N/A',
          deviceId: deviceId
        }, null, 2);

        const fileName = `${fileData.game_version}_${fileData.fps}fps_${fileData.bit_type}_${fileData.ipad_view ? 'ipad' : 'normal'}_${Date.now()}.sav`;
        const blob = new Blob([fileContent], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showMessage('File re-downloaded! Remember to move it to your PUBG game folder.', 'success');
      } catch (error) {
        console.error('Re-download file error:', error);
        showMessage(`Failed to re-download file: ${error.message}`, 'error');
      }
    }

    async function checkProfile() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!sessionId) {
        document.getElementById('create-profile-btn').style.display = 'block';
        document.getElementById('post-news-btn').style.display = 'none';
        return;
      }
      try {
        const { data, error } = await supabase.from('profiles').select('*').eq('id', sessionId).single();
        if (error && error.code !== 'PGRST116') throw new Error(`Profile fetch error: ${error.message}`); // PGRST116 means no rows found
        if (!data) {
          profileId = null;
          document.getElementById('create-profile-btn').style.display = 'block';
          document.getElementById('post-news-btn').style.display = 'none';
          console.log('No profile found for this session, showing create profile form');
        } else {
          profileId = data.id;
          document.getElementById('create-profile-btn').style.display = 'none';
          document.getElementById('post-news-btn').style.display = data.is_banned ? 'none' : 'block';
          if (data.is_banned) showMessage('Your profile is banned! You cannot post news.', 'error');
          console.log('Profile loaded:', data.username);
        }
      } catch (error) {
        console.error('Check profile error:', error);
        showMessage(`Profile check failed: ${error.message}`, 'error');
      }
    }

    function showCreateProfile() {
      document.getElementById('create-profile').style.display = 'block';
      document.getElementById('create-profile-btn').style.display = 'none';
      document.getElementById('post-news-btn').style.display = 'none';
    }

    function hideCreateProfile() {
      document.getElementById('create-profile').style.display = 'none';
      checkProfile(); // Re-evaluate button visibility
    }

    async function createProfile() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!sessionId) {
        showMessage('Please login first to create a profile.', 'error');
        return;
      }
      try {
        const username = document.getElementById('profile-username').value.trim();
        const name = document.getElementById('profile-name').value.trim();
        const file = document.getElementById('profile-picture').files[0];

        if (!username || !name) throw new Error('Username and Name are required.');

        // Check if username already exists
        const { data: existingUser, error: userCheckError } = await supabase
          .from('profiles')
          .select('id')
          .eq('username', username)
          .limit(1);
        if (userCheckError) throw new Error(`Username check error: ${userCheckError.message}`);
        if (existingUser && existingUser.length > 0) {
          throw new Error('Username already taken. Please choose a different one.');
        }

        let profilePicture = null;
        if (file) {
          const { data: uploadData, error: uploadError } = await supabase.storage
            .from('profile_pictures') // Use a dedicated bucket for profile pictures
            .upload(`public/${sessionId}/${Date.now()}_${file.name}`, file, {
              cacheControl: '3600',
              upsert: false
            });
          if (uploadError) throw new Error(`Profile picture upload error: ${uploadError.message}`);
          profilePicture = `${SUPABASE_URL}/storage/v1/object/public/profile_pictures/${uploadData.path}`;
        }

        const { error } = await supabase.from('profiles').insert({
          id: sessionId, // Use session ID as profile ID for 1:1 mapping
          username,
          name,
          profile_picture: profilePicture,
          is_banned: false,
        });
        if (error) throw new Error(`Profile insert error: ${error.message}`);

        showMessage('Profile created successfully!', 'success');
        document.getElementById('profile-username').value = '';
        document.getElementById('profile-name').value = '';
        document.getElementById('profile-picture').value = '';
        hideCreateProfile();
        checkProfile(); // Update profileId and button visibility
        console.log('Profile created:', username);
      } catch (error) {
        console.error('Create profile error:', error);
        showMessage(`Profile creation failed: ${error.message}`, 'error');
      }
    }

    function showPostNews() {
      document.getElementById('post-news').style.display = 'block';
      document.getElementById('create-profile-btn').style.display = 'none';
      document.getElementById('post-news-btn').style.display = 'none';
    }

    function hidePostNews() {
      document.getElementById('post-news').style.display = 'none';
      checkProfile(); // Re-evaluate button visibility
    }

    async function postNews() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!profileId) {
        showMessage('Please create a profile first to post news.', 'error');
        return;
      }
      try {
        const title = document.getElementById('news-title').value.trim();
        const content = document.getElementById('news-content').value.trim();
        const youtubeLink = document.getElementById('news-youtube').value.trim();
        const file = document.getElementById('news-image').files[0];

        if (!title || !content) throw new Error('Title and content are required.');

        let imageUrl = null;
        if (file) {
          const { data: uploadData, error: uploadError } = await supabase.storage
            .from('news_images') // Dedicated bucket for news images
            .upload(`public/${profileId}/${Date.now()}_${file.name}`, file, {
              cacheControl: '3600',
              upsert: false
            });
          if (uploadError) throw new Error(`Image upload error: ${uploadError.message}`);
          imageUrl = `${SUPABASE_URL}/storage/v1/object/public/news_images/${uploadData.path}`;
        }

        const { error } = await supabase.from('news').insert({
          title,
          content,
          youtube_link: youtubeLink || null,
          image_url: imageUrl,
          profile_id: profileId,
          is_admin: false, // User-posted news
        });
        if (error) throw new Error(`News insert error: ${error.message}`);

        showMessage('News posted successfully!', 'success');
        document.getElementById('news-title').value = '';
        document.getElementById('news-content').value = '';
        document.getElementById('news-youtube').value = '';
        document.getElementById('news-image').value = '';
        hidePostNews();
        loadNews();
        console.log('News posted:', title);
      } catch (error) {
        console.error('Post news error:', error);
        showMessage(`News posting failed: ${error.message}`, 'error');
      }
    }

    async function loadNews() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const { data, error } = await supabase
          .from('news')
          .select('*, profiles(username, name, profile_picture)')
          .order('created_at', { ascending: false });
        if (error) throw new Error(`News fetch error: ${error.message}`);

        const newsList = document.getElementById('news-list');
        newsList.innerHTML = '';
        if (data.length === 0) {
          newsList.innerHTML = '<p>No news found.</p>';
          return;
        }
        data.forEach(news => {
          // Clear previous timer if exists
          if (viewTimers[news.id]) clearTimeout(viewTimers[news.id]);
          // Set a new timer for 3 seconds to increment view count
          viewTimers[news.id] = setTimeout(() => incrementViewCount(news.id), 3000);

          newsList.innerHTML += `
            <div class="news-card" id="news-card-${news.id}">
              <div class="author-info">
                <img src="${news.profiles?.profile_picture || '/placeholder.svg?height=32&width=32'}" class="profile-pic" alt="Profile Picture">
                <p><strong>${news.profiles?.name || 'Unknown'}</strong> (@${news.profiles?.username || 'Anonymous'})</p>
              </div>
              <h3>${news.title}</h3>
              <p>${news.content}</p>
              ${news.image_url ? `<img src="${news.image_url}" alt="News Image">` : ''}
              ${news.youtube_link ? `<p><a href="${news.youtube_link}" target="_blank">Watch on YouTube</a></p>` : ''}
              <p class="views">Views: <span id="views-count-${news.id}">${news.views}</span></p>
              <div id="comments-${news.id}" style="margin-top: 15px;"></div>
              <textarea id="comment-input-${news.id}" placeholder="Add a comment" rows="2" style="margin-top: 10px;"></textarea>
              <button onclick="postComment('${news.id}')" style="margin-top: 5px;">Comment</button>
              ${profileId === news.profile_id ? `
                <button onclick="editNews('${news.id}')" style="margin-top: 5px; background: #007bff;">Edit</button>
                <button onclick="deleteNews('${news.id}')" style="margin-top: 5px; background: #dc3545;">Delete</button>
              ` : ''}
            </div>
          `;
          loadComments(news.id);
        });
        console.log('News loaded:', data.length);
      } catch (error) {
        console.error('Load news error:', error);
        showMessage(`Failed to load news: ${error.message}`, 'error');
      }
    }

    async function incrementViewCount(newsId) {
      if (!supabase) {
        console.error('Supabase client not initialized for view count.');
        return;
      }
      try {
        const { error } = await supabase
          .from('news')
          .update({ views: supabase.raw('views + 1') })
          .eq('id', newsId);
        if (error) console.error(`View count update error for ${newsId}: ${error.message}`);
        else {
          const viewsSpan = document.getElementById(`views-count-${newsId}`);
          if (viewsSpan) viewsSpan.textContent = parseInt(viewsSpan.textContent) + 1;
          console.log('View count incremented for news:', newsId);
        }
      } catch (error) {
        console.error('Increment view count error:', error);
      }
    }

    async function postComment(newsId, parentId = null) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!profileId) {
        showMessage('Please create a profile first to comment.', 'error');
        return;
      }
      try {
        const inputId = parentId ? `reply-input-${parentId}` : `comment-input-${newsId}`;
        const content = document.getElementById(inputId).value.trim();
        if (!content) throw new Error('Comment content is empty.');

        const { error } = await supabase.from('comments').insert({
          news_id: newsId,
          content,
          profile_id: profileId,
          parent_id: parentId,
        });
        if (error) throw new Error(`Comment insert error: ${error.message}`);

        showMessage('Comment posted successfully!', 'success');
        document.getElementById(inputId).value = '';
        if (parentId) document.getElementById(`reply-form-${parentId}`).style.display = 'none';
        loadComments(newsId);
        console.log('Comment posted for news:', newsId);
      } catch (error) {
        console.error('Post comment error:', error);
        showMessage(`Comment posting failed: ${error.message}`, 'error');
      }
    }

    async function loadComments(newsId) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const { data, error } = await supabase
          .from('comments')
          .select('*, profiles(username, name, profile_picture)')
          .eq('news_id', newsId)
          .order('created_at', { ascending: true });
        if (error) throw new Error(`Comments fetch error: ${error.message}`);

        const commentsDiv = document.getElementById(`comments-${newsId}`);
        commentsDiv.innerHTML = '';
        if (data.length === 0) {
          commentsDiv.innerHTML = '<p>No comments yet.</p>';
          return;
        }

        const renderComment = (comment, isReply = false) => {
          const commentHtml = `
            <div class="comment ${isReply ? 'reply' : ''}">
              <div class="comment-author-info">
                <img src="${comment.profiles?.profile_picture || '/placeholder.svg?height=24&width=24'}" class="profile-pic" alt="Profile Picture">
                <p><strong>${comment.profiles?.name || 'Unknown'}</strong> (@${comment.profiles?.username || 'Anonymous'})</p>
              </div>
              <p>${comment.content}</p>
              <button onclick="showReplyForm('${comment.id}', '${newsId}')" style="font-size: 12px; padding: 5px 10px; margin-top: 5px; background: #007bff;">Reply</button>
              <div id="reply-form-${comment.id}" style="display: none; margin-top: 5px;">
                <textarea id="reply-input-${comment.id}" placeholder="Reply" rows="1" style="width: calc(100% - 10px); margin-bottom: 5px;"></textarea>
                <button onclick="postComment('${newsId}', '${comment.id}')" style="font-size: 12px; padding: 5px 10px; background: #28a745;">Post Reply</button>
              </div>
            </div>
          `;
          commentsDiv.innerHTML += commentHtml;
        };

        // Render top-level comments first
        data.filter(c => !c.parent_id).forEach(comment => renderComment(comment, false));
        // Then render replies
        data.filter(c => c.parent_id).forEach(reply => renderComment(reply, true));

        console.log('Comments loaded for news:', newsId);
      } catch (error) {
        console.error('Load comments error:', error);
        showMessage(`Failed to load comments: ${error.message}`, 'error');
      }
    }

    function showReplyForm(commentId, newsId) {
      const replyForm = document.getElementById(`reply-form-${commentId}`);
      if (replyForm) {
        replyForm.style.display = replyForm.style.display === 'block' ? 'none' : 'block';
        console.log('Toggling reply form for comment:', commentId);
      }
    }

    async function editNews(newsId) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const { data, error } = await supabase.from('news').select('*').eq('id', newsId).single();
        if (error || !data) throw new Error(`News not found: ${error?.message}`);

        // Populate the post news form with existing data for editing
        document.getElementById('news-title').value = data.title;
        document.getElementById('news-content').value = data.content;
        document.getElementById('news-youtube').value = data.youtube_link || '';
        // Image input cannot be pre-filled for security reasons, user must re-upload if needed

        document.getElementById('post-news').style.display = 'block';
        document.getElementById('create-profile-btn').style.display = 'none';
        document.getElementById('post-news-btn').style.display = 'none';

        // Change post button to update button
        const postButton = document.querySelector('#post-news button[onclick="postNews()"]');
        postButton.textContent = 'Update News';
        postButton.onclick = () => updateNews(newsId);
        showMessage('Editing news. Re-upload image if you want to change it.', 'success');
        console.log('Editing news:', newsId);
      } catch (error) {
        console.error('Edit news error:', error);
        showMessage(`Failed to load news for editing: ${error.message}`, 'error');
      }
    }

    async function updateNews(newsId) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      try {
        const title = document.getElementById('news-title').value.trim();
        const content = document.getElementById('news-content').value.trim();
        const youtubeLink = document.getElementById('news-youtube').value.trim();
        const file = document.getElementById('news-image').files[0];

        if (!title || !content) throw new Error('Title and content are required.');

        let imageUrl = null;
        if (file) {
          const { data: uploadData, error: uploadError } = await supabase.storage
            .from('news_images')
            .upload(`public/${profileId}/${Date.now()}_${file.name}`, file, {
              cacheControl: '3600',
              upsert: false
            });
          if (uploadError) throw new Error(`Image upload error: ${uploadError.message}`);
          imageUrl = `${SUPABASE_URL}/storage/v1/object/public/news_images/${uploadData.path}`;
        }

        const updates = {
          title,
          content,
          youtube_link: youtubeLink || null,
        };
        if (imageUrl) {
          updates.image_url = imageUrl;
        }

        const { error } = await supabase.from('news').update(updates).eq('id', newsId);
        if (error) throw new Error(`News update error: ${error.message}`);

        showMessage('News updated successfully!', 'success');
        document.getElementById('news-title').value = '';
        document.getElementById('news-content').value = '';
        document.getElementById('news-youtube').value = '';
        document.getElementById('news-image').value = '';
        hidePostNews();
        loadNews();
        // Reset post button
        const postButton = document.querySelector('#post-news button[onclick^="updateNews"]');
        postButton.textContent = 'Post';
        postButton.onclick = postNews;
        console.log('News updated:', newsId);
      } catch (error) {
        console.error('Update news error:', error);
        showMessage(`News update failed: ${error.message}`, 'error');
      }
    }

    async function deleteNews(newsId) {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!confirm('Are you sure you want to delete this news?')) return;
      try {
        const { error } = await supabase.from('news').delete().eq('id', newsId);
        if (error) throw new Error(`News delete error: ${error.message}`);
        showMessage('News deleted successfully!', 'success');
        loadNews();
        console.log('News deleted:', newsId);
      } catch (error) {
        console.error('Delete news error:', error);
        showMessage(`News deletion failed: ${error.message}`, 'error');
      }
    }

    async function loadSupportMessages() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!profileId) {
        document.getElementById('support-messages').innerHTML = '<p>Please create a profile to view and send support messages.</p>';
        return;
      }
      try {
        const { data, error } = await supabase
          .from('support_messages')
          .select('*, profiles(username, name)')
          .order('created_at', { ascending: true });
        if (error) throw new Error(`Support messages fetch error: ${error.message}`);

        const messagesDiv = document.getElementById('support-messages');
        messagesDiv.innerHTML = '';
        if (data.length === 0) {
          messagesDiv.innerHTML = '<p>No support messages yet. Start a conversation!</p>';
          return;
        }
        data.forEach(msg => {
          const senderName = msg.is_from_user ? (msg.profiles?.name || 'You') : 'Admin';
          const senderUsername = msg.is_from_user ? `@${msg.profiles?.username || 'Anonymous'}` : '';
          messagesDiv.innerHTML += `
            <div class="message ${msg.is_from_user ? 'user-message' : 'admin-message'}" style="text-align: ${msg.is_from_user ? 'right' : 'left'}; background: ${msg.is_from_user ? '#007bff' : '#6c757d'}; margin-left: ${msg.is_from_user ? 'auto' : '0'}; margin-right: ${msg.is_from_user ? '0' : 'auto'}; max-width: 80%; padding: 8px; border-radius: 8px; margin-bottom: 5px;">
              <p><strong>${senderName}</strong> ${senderUsername}: ${msg.content}</p>
              <p style="font-size: 10px; opacity: 0.8;">${new Date(msg.created_at).toLocaleString()}</p>
            </div>
          `;
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight; // Scroll to bottom
        console.log('Support messages loaded:', data.length);
      } catch (error) {
        console.error('Load support messages error:', error);
        showMessage(`Failed to load support messages: ${error.message}`, 'error');
      }
    }

    async function sendSupportMessage() {
      if (!(await checkInternet())) return;
      if (!supabase) {
        showMessage('Database not connected.', 'error');
        return;
      }
      if (!profileId) {
        showMessage('Please create a profile first to send support messages.', 'error');
        return;
      }
      try {
        const content = document.getElementById('support-input').value.trim();
        if (!content) throw new Error('Support message is empty.');

        const { error } = await supabase.from('support_messages').insert({
          content,
          is_from_user: true,
          profile_id: profileId,
        });
        if (error) throw new Error(`Support message insert error: ${error.message}`);

        // Send to Telegram Bot (this requires a server-side proxy or direct bot API access if allowed by Telegram)
        // For client-side, this is a direct call, which might expose your bot token.
        // In a real app, you'd send this to your own backend, which then calls Telegram API.
        const telegramResponse = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: TELEGRAM_GROUP_ID,
            text: `New Support Message from User (Profile ID: ${profileId}):\n${content}`,
          }),
        });
        if (!telegramResponse.ok) {
          console.warn(`Telegram API request failed: ${telegramResponse.statusText}. Message sent to DB but not Telegram.`);
        }

        showMessage('Support message sent!', 'success');
        document.getElementById('support-input').value = '';
        loadSupportMessages();
        console.log('Support message sent:', content);
      } catch (error) {
        console.error('Send support message error:', error);
        showMessage(`Support message failed: ${error.message}`, 'error');
      }
    }

    async function loadTelegramPosts() {
      // This function is a placeholder.
      // Directly fetching Telegram channel posts from a client-side web app is not feasible
      // due to CORS restrictions and the need for server-side authentication with Telegram API.
      // You would typically need a backend server to fetch posts from Telegram and then expose them via your own API.
      document.getElementById('telegram-posts').innerHTML = `
        <p>Telegram channel posts cannot be directly displayed here due to browser security policies and Telegram API limitations for client-side applications.</p>
        <p>To implement this, you would need a backend server to fetch posts from your Telegram channel (${TELEGRAM_GROUP_ID}) and then serve them to this web application.</p>
        <p>You can still provide a direct link to your Telegram channel:</p>
        <p><a href="https://t.me/c/${TELEGRAM_GROUP_ID.replace('-100', '')}" target="_blank">Join our Telegram Channel</a></p>
      `;
      console.log('Loading Telegram posts (placeholder)');
    }

    function setupRealtimeSubscriptions() {
      if (!supabase || typeof supabase.channel !== 'function') {
        console.error('Cannot setup subscriptions: Supabase client or channel method not available');
        showMessage('Realtime subscriptions failed: Database not properly initialized.', 'error');
        return;
      }

      // Realtime for key changes (for auto-logout/status update)
      supabase
        .channel('key_changes')
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'keys', filter: `key_text=eq.${document.getElementById('key-input').value.trim()}` }, payload => {
          console.log('Key update received:', payload);
          if (payload.new.is_active === false || new Date(payload.new.expires_at) < new Date()) {
            showMessage('Your key has been deactivated or expired by admin. Logging out...', 'error');
            logout();
          } else if (payload.new.max_devices < payload.old.max_devices) {
            // If max_devices is reduced, check if current session is still valid
            supabase.from('sessions').select('id', { count: 'exact' }).eq('key_id', payload.new.id).eq('is_active', true)
              .then(({ count, error }) => {
                if (error) console.error('Error checking session count:', error);
                if (count > payload.new.max_devices) {
                  showMessage('Device limit for your key has been reduced. Logging out...', 'error');
                  logout();
                }
              });
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') console.log('Subscribed to key_changes channel');
          else if (err) console.error('Key changes subscription error:', err);
        });

      // Realtime for news
      supabase
        .channel('news_changes')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'news' }, payload => {
          console.log('News update received:', payload);
          if (document.getElementById('news-section').style.display === 'block') {
            loadNews(); // Reload news if on news section
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') console.log('Subscribed to news_changes channel');
          else if (err) console.error('News changes subscription error:', err);
        });

      // Realtime for comments
      supabase
        .channel('comments_changes')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, payload => {
          console.log('Comment update received:', payload);
          if (document.getElementById('news-section').style.display === 'block') {
            // Reload comments for the specific news item if possible, or all news
            const newsId = payload.new.news_id || payload.old.news_id;
            if (newsId) loadComments(newsId);
            else loadNews();
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') console.log('Subscribed to comments_changes channel');
          else if (err) console.error('Comments changes subscription error:', err);
        });

      // Realtime for support messages
      supabase
        .channel('support_messages_changes')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'support_messages' }, payload => {
          console.log('Support message update received:', payload);
          if (document.getElementById('support-section').style.display === 'block') {
            loadSupportMessages(); // Reload support messages if on support section
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') console.log('Subscribed to support_messages_changes channel');
          else if (err) console.error('Support messages subscription error:', err);
        });

      // Realtime for profiles (for ban status)
      supabase
        .channel('profiles_changes')
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'profiles', filter: `id=eq.${sessionId}` }, payload => {
          console.log('Profile update received:', payload);
          if (payload.new.is_banned === true) {
            showMessage('Your profile has been banned by admin. You cannot post news or comments.', 'error');
            document.getElementById('post-news-btn').style.display = 'none';
            document.getElementById('create-profile-btn').style.display = 'none'; // If they are banned, they can't create new profile either
          } else {
            checkProfile(); // Re-evaluate profile status and button visibility
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') console.log('Subscribed to profiles_changes channel');
          else if (err) console.error('Profiles changes subscription error:', err);
        });
    }

    // Initialize Supabase client on page load
    window.addEventListener('load', async () => {
      if (await checkInternet()) {
        initializeSupabase();
      }
    });
  </script>
</body>
</html>
